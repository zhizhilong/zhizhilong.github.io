((typeof self !== 'undefined' ? self : this)["webpackJsonp"] = (typeof self !== 'undefined' ? self : this)["webpackJsonp"] || []).push([["npm.echarts-liquidfill"],{

/***/ "./node_modules/echarts-liquidfill/src/liquidFill.js":
/*!***********************************************************!*\
  !*** ./node_modules/echarts-liquidfill/src/liquidFill.js ***!
  \***********************************************************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _liquidFillSeries__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./liquidFillSeries */ \"./node_modules/echarts-liquidfill/src/liquidFillSeries.js\");\n/* harmony import */ var _liquidFillView__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./liquidFillView */ \"./node_modules/echarts-liquidfill/src/liquidFillView.js\");\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy1saXF1aWRmaWxsL3NyYy9saXF1aWRGaWxsLmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2VjaGFydHMtbGlxdWlkZmlsbC9zcmMvbGlxdWlkRmlsbC5qcz9hOThlIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCAnLi9saXF1aWRGaWxsU2VyaWVzJztcbmltcG9ydCAnLi9saXF1aWRGaWxsVmlldyc7Il0sIm1hcHBpbmdzIjoiQUFBQTtBQUFBO0FBQUE7QUFBQTsiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/echarts-liquidfill/src/liquidFill.js\n");

/***/ }),

/***/ "./node_modules/echarts-liquidfill/src/liquidFillSeries.js":
/*!*****************************************************************!*\
  !*** ./node_modules/echarts-liquidfill/src/liquidFillSeries.js ***!
  \*****************************************************************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var echarts_lib_echarts__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! echarts/lib/echarts */ \"./node_modules/echarts/lib/echarts.js\");\n\n\necharts_lib_echarts__WEBPACK_IMPORTED_MODULE_0__[\"extendSeriesModel\"]({\n\n    type: 'series.liquidFill',\n\n    optionUpdated: function () {\n        var option = this.option;\n        option.gridSize = Math.max(Math.floor(option.gridSize), 4);\n    },\n\n    getInitialData: function (option, ecModel) {\n        var dimensions = echarts_lib_echarts__WEBPACK_IMPORTED_MODULE_0__[\"helper\"].createDimensions(option.data, {\n            coordDimensions: ['value']\n        });\n        var list = new echarts_lib_echarts__WEBPACK_IMPORTED_MODULE_0__[\"List\"](dimensions, this);\n        list.initData(option.data);\n        return list;\n    },\n\n    defaultOption: {\n        color: ['#294D99', '#156ACF', '#1598ED', '#45BDFF'],\n        center: ['50%', '50%'],\n        radius: '50%',\n        amplitude: '8%',\n        waveLength: '80%',\n        phase: 'auto',\n        period: 'auto',\n        direction: 'right',\n        shape: 'circle',\n\n        waveAnimation: true,\n        animationEasing: 'linear',\n        animationEasingUpdate: 'linear',\n        animationDuration: 2000,\n        animationDurationUpdate: 1000,\n\n        outline: {\n            show: true,\n            borderDistance: 8,\n            itemStyle: {\n                color: 'none',\n                borderColor: '#294D99',\n                borderWidth: 8,\n                shadowBlur: 20,\n                shadowColor: 'rgba(0, 0, 0, 0.25)'\n            }\n        },\n\n        backgroundStyle: {\n            color: '#E3F7FF'\n        },\n\n        itemStyle: {\n            opacity: 0.95,\n            shadowBlur: 50,\n            shadowColor: 'rgba(0, 0, 0, 0.4)'\n        },\n\n        label: {\n            show: true,\n            color: '#294D99',\n            insideColor: '#fff',\n            fontSize: 50,\n            fontWeight: 'bold',\n\n            align: 'center',\n            baseline: 'middle',\n            position: 'inside'\n        },\n\n        emphasis: {\n            itemStyle: {\n                opacity: 0.8\n            }\n        }\n    }\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy1saXF1aWRmaWxsL3NyYy9saXF1aWRGaWxsU2VyaWVzLmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2VjaGFydHMtbGlxdWlkZmlsbC9zcmMvbGlxdWlkRmlsbFNlcmllcy5qcz8zMmY4Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCAqIGFzIGVjaGFydHMgZnJvbSAnZWNoYXJ0cy9saWIvZWNoYXJ0cyc7XG5cbmVjaGFydHMuZXh0ZW5kU2VyaWVzTW9kZWwoe1xuXG4gICAgdHlwZTogJ3Nlcmllcy5saXF1aWRGaWxsJyxcblxuICAgIG9wdGlvblVwZGF0ZWQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIG9wdGlvbiA9IHRoaXMub3B0aW9uO1xuICAgICAgICBvcHRpb24uZ3JpZFNpemUgPSBNYXRoLm1heChNYXRoLmZsb29yKG9wdGlvbi5ncmlkU2l6ZSksIDQpO1xuICAgIH0sXG5cbiAgICBnZXRJbml0aWFsRGF0YTogZnVuY3Rpb24gKG9wdGlvbiwgZWNNb2RlbCkge1xuICAgICAgICB2YXIgZGltZW5zaW9ucyA9IGVjaGFydHMuaGVscGVyLmNyZWF0ZURpbWVuc2lvbnMob3B0aW9uLmRhdGEsIHtcbiAgICAgICAgICAgIGNvb3JkRGltZW5zaW9uczogWyd2YWx1ZSddXG4gICAgICAgIH0pO1xuICAgICAgICB2YXIgbGlzdCA9IG5ldyBlY2hhcnRzLkxpc3QoZGltZW5zaW9ucywgdGhpcyk7XG4gICAgICAgIGxpc3QuaW5pdERhdGEob3B0aW9uLmRhdGEpO1xuICAgICAgICByZXR1cm4gbGlzdDtcbiAgICB9LFxuXG4gICAgZGVmYXVsdE9wdGlvbjoge1xuICAgICAgICBjb2xvcjogWycjMjk0RDk5JywgJyMxNTZBQ0YnLCAnIzE1OThFRCcsICcjNDVCREZGJ10sXG4gICAgICAgIGNlbnRlcjogWyc1MCUnLCAnNTAlJ10sXG4gICAgICAgIHJhZGl1czogJzUwJScsXG4gICAgICAgIGFtcGxpdHVkZTogJzglJyxcbiAgICAgICAgd2F2ZUxlbmd0aDogJzgwJScsXG4gICAgICAgIHBoYXNlOiAnYXV0bycsXG4gICAgICAgIHBlcmlvZDogJ2F1dG8nLFxuICAgICAgICBkaXJlY3Rpb246ICdyaWdodCcsXG4gICAgICAgIHNoYXBlOiAnY2lyY2xlJyxcblxuICAgICAgICB3YXZlQW5pbWF0aW9uOiB0cnVlLFxuICAgICAgICBhbmltYXRpb25FYXNpbmc6ICdsaW5lYXInLFxuICAgICAgICBhbmltYXRpb25FYXNpbmdVcGRhdGU6ICdsaW5lYXInLFxuICAgICAgICBhbmltYXRpb25EdXJhdGlvbjogMjAwMCxcbiAgICAgICAgYW5pbWF0aW9uRHVyYXRpb25VcGRhdGU6IDEwMDAsXG5cbiAgICAgICAgb3V0bGluZToge1xuICAgICAgICAgICAgc2hvdzogdHJ1ZSxcbiAgICAgICAgICAgIGJvcmRlckRpc3RhbmNlOiA4LFxuICAgICAgICAgICAgaXRlbVN0eWxlOiB7XG4gICAgICAgICAgICAgICAgY29sb3I6ICdub25lJyxcbiAgICAgICAgICAgICAgICBib3JkZXJDb2xvcjogJyMyOTREOTknLFxuICAgICAgICAgICAgICAgIGJvcmRlcldpZHRoOiA4LFxuICAgICAgICAgICAgICAgIHNoYWRvd0JsdXI6IDIwLFxuICAgICAgICAgICAgICAgIHNoYWRvd0NvbG9yOiAncmdiYSgwLCAwLCAwLCAwLjI1KSdcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBiYWNrZ3JvdW5kU3R5bGU6IHtcbiAgICAgICAgICAgIGNvbG9yOiAnI0UzRjdGRidcbiAgICAgICAgfSxcblxuICAgICAgICBpdGVtU3R5bGU6IHtcbiAgICAgICAgICAgIG9wYWNpdHk6IDAuOTUsXG4gICAgICAgICAgICBzaGFkb3dCbHVyOiA1MCxcbiAgICAgICAgICAgIHNoYWRvd0NvbG9yOiAncmdiYSgwLCAwLCAwLCAwLjQpJ1xuICAgICAgICB9LFxuXG4gICAgICAgIGxhYmVsOiB7XG4gICAgICAgICAgICBzaG93OiB0cnVlLFxuICAgICAgICAgICAgY29sb3I6ICcjMjk0RDk5JyxcbiAgICAgICAgICAgIGluc2lkZUNvbG9yOiAnI2ZmZicsXG4gICAgICAgICAgICBmb250U2l6ZTogNTAsXG4gICAgICAgICAgICBmb250V2VpZ2h0OiAnYm9sZCcsXG5cbiAgICAgICAgICAgIGFsaWduOiAnY2VudGVyJyxcbiAgICAgICAgICAgIGJhc2VsaW5lOiAnbWlkZGxlJyxcbiAgICAgICAgICAgIHBvc2l0aW9uOiAnaW5zaWRlJ1xuICAgICAgICB9LFxuXG4gICAgICAgIGVtcGhhc2lzOiB7XG4gICAgICAgICAgICBpdGVtU3R5bGU6IHtcbiAgICAgICAgICAgICAgICBvcGFjaXR5OiAwLjhcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn0pO1xuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/echarts-liquidfill/src/liquidFillSeries.js\n");

/***/ }),

/***/ "./node_modules/echarts-liquidfill/src/liquidFillShape.js":
/*!****************************************************************!*\
  !*** ./node_modules/echarts-liquidfill/src/liquidFillShape.js ***!
  \****************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var echarts_lib_echarts__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! echarts/lib/echarts */ \"./node_modules/echarts/lib/echarts.js\");\n\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (echarts_lib_echarts__WEBPACK_IMPORTED_MODULE_0__[\"graphic\"].extendShape({\n    type: 'ec-liquid-fill',\n\n    shape: {\n        waveLength: 0,\n        radius: 0,\n        radiusY: 0,\n        cx: 0,\n        cy: 0,\n        waterLevel: 0,\n        amplitude: 0,\n        phase: 0,\n        inverse: false\n    },\n\n    buildPath: function (ctx, shape) {\n        if (shape.radiusY == null) {\n            shape.radiusY = shape.radius;\n        }\n\n        /**\n         * We define a sine wave having 4 waves, and make sure at least 8 curves\n         * is drawn. Otherwise, it may cause blank area for some waves when\n         * wave length is large enough.\n         */\n        var curves = Math.max(\n            Math.ceil(2 * shape.radius / shape.waveLength * 4) * 2,\n            8\n        );\n\n        // map phase to [-Math.PI * 2, 0]\n        while (shape.phase < -Math.PI * 2) {\n            shape.phase += Math.PI * 2;\n        }\n        while (shape.phase > 0) {\n            shape.phase -= Math.PI * 2;\n        }\n        var phase = shape.phase / Math.PI / 2 * shape.waveLength;\n\n        var left = shape.cx - shape.radius + phase - shape.radius * 2;\n\n        /**\n         * top-left corner as start point\n         *\n         * draws this point\n         *  |\n         * \\|/\n         *  ~~~~~~~~\n         *  |      |\n         *  +------+\n         */\n        ctx.moveTo(left, shape.waterLevel);\n\n        /**\n         * top wave\n         *\n         * ~~~~~~~~ <- draws this sine wave\n         * |      |\n         * +------+\n         */\n        var waveRight = 0;\n        for (var c = 0; c < curves; ++c) {\n            var stage = c % 4;\n            var pos = getWaterPositions(c * shape.waveLength / 4, stage,\n                shape.waveLength, shape.amplitude);\n            ctx.bezierCurveTo(pos[0][0] + left, -pos[0][1] + shape.waterLevel,\n                pos[1][0] + left, -pos[1][1] + shape.waterLevel,\n                pos[2][0] + left, -pos[2][1] + shape.waterLevel);\n\n            if (c === curves - 1) {\n                waveRight = pos[2][0];\n            }\n        }\n\n        if (shape.inverse) {\n            /**\n             * top-right corner\n             *                  2. draws this line\n             *                          |\n             *                       +------+\n             * 3. draws this line -> |      | <- 1. draws this line\n             *                       ~~~~~~~~\n             */\n            ctx.lineTo(waveRight + left, shape.cy - shape.radiusY);\n            ctx.lineTo(left, shape.cy - shape.radiusY);\n            ctx.lineTo(left, shape.waterLevel);\n        }\n        else {\n            /**\n             * top-right corner\n             *\n             *                       ~~~~~~~~\n             * 3. draws this line -> |      | <- 1. draws this line\n             *                       +------+\n             *                          ^\n             *                          |\n             *                  2. draws this line\n             */\n            ctx.lineTo(waveRight + left, shape.cy + shape.radiusY);\n            ctx.lineTo(left, shape.cy + shape.radiusY);\n            ctx.lineTo(left, shape.waterLevel);\n        }\n\n        ctx.closePath();\n    }\n}));\n\n\n\n/**\n * Using Bezier curves to fit sine wave.\n * There is 4 control points for each curve of wave,\n * which is at 1/4 wave length of the sine wave.\n *\n * The control points for a wave from (a) to (d) are a-b-c-d:\n *          c *----* d\n *     b *\n *       |\n * ... a * ..................\n *\n * whose positions are a: (0, 0), b: (0.5, 0.5), c: (1, 1), d: (PI / 2, 1)\n *\n * @param {number} x          x position of the left-most point (a)\n * @param {number} stage      0-3, stating which part of the wave it is\n * @param {number} waveLength wave length of the sine wave\n * @param {number} amplitude  wave amplitude\n */\nfunction getWaterPositions(x, stage, waveLength, amplitude) {\n    if (stage === 0) {\n        return [\n            [x + 1 / 2 * waveLength / Math.PI / 2, amplitude / 2],\n            [x + 1 / 2 * waveLength / Math.PI,     amplitude],\n            [x + waveLength / 4,                   amplitude]\n        ];\n    }\n    else if (stage === 1) {\n        return [\n            [x + 1 / 2 * waveLength / Math.PI / 2 * (Math.PI - 2),\n            amplitude],\n            [x + 1 / 2 * waveLength / Math.PI / 2 * (Math.PI - 1),\n            amplitude / 2],\n            [x + waveLength / 4,                   0]\n        ]\n    }\n    else if (stage === 2) {\n        return [\n            [x + 1 / 2 * waveLength / Math.PI / 2, -amplitude / 2],\n            [x + 1 / 2 * waveLength / Math.PI,     -amplitude],\n            [x + waveLength / 4,                   -amplitude]\n        ]\n    }\n    else {\n        return [\n            [x + 1 / 2 * waveLength / Math.PI / 2 * (Math.PI - 2),\n            -amplitude],\n            [x + 1 / 2 * waveLength / Math.PI / 2 * (Math.PI - 1),\n            -amplitude / 2],\n            [x + waveLength / 4,                   0]\n        ]\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy1saXF1aWRmaWxsL3NyYy9saXF1aWRGaWxsU2hhcGUuanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy1saXF1aWRmaWxsL3NyYy9saXF1aWRGaWxsU2hhcGUuanM/NjFiMyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgKiBhcyBlY2hhcnRzIGZyb20gJ2VjaGFydHMvbGliL2VjaGFydHMnO1xuXG5leHBvcnQgZGVmYXVsdCBlY2hhcnRzLmdyYXBoaWMuZXh0ZW5kU2hhcGUoe1xuICAgIHR5cGU6ICdlYy1saXF1aWQtZmlsbCcsXG5cbiAgICBzaGFwZToge1xuICAgICAgICB3YXZlTGVuZ3RoOiAwLFxuICAgICAgICByYWRpdXM6IDAsXG4gICAgICAgIHJhZGl1c1k6IDAsXG4gICAgICAgIGN4OiAwLFxuICAgICAgICBjeTogMCxcbiAgICAgICAgd2F0ZXJMZXZlbDogMCxcbiAgICAgICAgYW1wbGl0dWRlOiAwLFxuICAgICAgICBwaGFzZTogMCxcbiAgICAgICAgaW52ZXJzZTogZmFsc2VcbiAgICB9LFxuXG4gICAgYnVpbGRQYXRoOiBmdW5jdGlvbiAoY3R4LCBzaGFwZSkge1xuICAgICAgICBpZiAoc2hhcGUucmFkaXVzWSA9PSBudWxsKSB7XG4gICAgICAgICAgICBzaGFwZS5yYWRpdXNZID0gc2hhcGUucmFkaXVzO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFdlIGRlZmluZSBhIHNpbmUgd2F2ZSBoYXZpbmcgNCB3YXZlcywgYW5kIG1ha2Ugc3VyZSBhdCBsZWFzdCA4IGN1cnZlc1xuICAgICAgICAgKiBpcyBkcmF3bi4gT3RoZXJ3aXNlLCBpdCBtYXkgY2F1c2UgYmxhbmsgYXJlYSBmb3Igc29tZSB3YXZlcyB3aGVuXG4gICAgICAgICAqIHdhdmUgbGVuZ3RoIGlzIGxhcmdlIGVub3VnaC5cbiAgICAgICAgICovXG4gICAgICAgIHZhciBjdXJ2ZXMgPSBNYXRoLm1heChcbiAgICAgICAgICAgIE1hdGguY2VpbCgyICogc2hhcGUucmFkaXVzIC8gc2hhcGUud2F2ZUxlbmd0aCAqIDQpICogMixcbiAgICAgICAgICAgIDhcbiAgICAgICAgKTtcblxuICAgICAgICAvLyBtYXAgcGhhc2UgdG8gWy1NYXRoLlBJICogMiwgMF1cbiAgICAgICAgd2hpbGUgKHNoYXBlLnBoYXNlIDwgLU1hdGguUEkgKiAyKSB7XG4gICAgICAgICAgICBzaGFwZS5waGFzZSArPSBNYXRoLlBJICogMjtcbiAgICAgICAgfVxuICAgICAgICB3aGlsZSAoc2hhcGUucGhhc2UgPiAwKSB7XG4gICAgICAgICAgICBzaGFwZS5waGFzZSAtPSBNYXRoLlBJICogMjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgcGhhc2UgPSBzaGFwZS5waGFzZSAvIE1hdGguUEkgLyAyICogc2hhcGUud2F2ZUxlbmd0aDtcblxuICAgICAgICB2YXIgbGVmdCA9IHNoYXBlLmN4IC0gc2hhcGUucmFkaXVzICsgcGhhc2UgLSBzaGFwZS5yYWRpdXMgKiAyO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiB0b3AtbGVmdCBjb3JuZXIgYXMgc3RhcnQgcG9pbnRcbiAgICAgICAgICpcbiAgICAgICAgICogZHJhd3MgdGhpcyBwb2ludFxuICAgICAgICAgKiAgfFxuICAgICAgICAgKiBcXHwvXG4gICAgICAgICAqICB+fn5+fn5+flxuICAgICAgICAgKiAgfCAgICAgIHxcbiAgICAgICAgICogICstLS0tLS0rXG4gICAgICAgICAqL1xuICAgICAgICBjdHgubW92ZVRvKGxlZnQsIHNoYXBlLndhdGVyTGV2ZWwpO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiB0b3Agd2F2ZVxuICAgICAgICAgKlxuICAgICAgICAgKiB+fn5+fn5+fiA8LSBkcmF3cyB0aGlzIHNpbmUgd2F2ZVxuICAgICAgICAgKiB8ICAgICAgfFxuICAgICAgICAgKiArLS0tLS0tK1xuICAgICAgICAgKi9cbiAgICAgICAgdmFyIHdhdmVSaWdodCA9IDA7XG4gICAgICAgIGZvciAodmFyIGMgPSAwOyBjIDwgY3VydmVzOyArK2MpIHtcbiAgICAgICAgICAgIHZhciBzdGFnZSA9IGMgJSA0O1xuICAgICAgICAgICAgdmFyIHBvcyA9IGdldFdhdGVyUG9zaXRpb25zKGMgKiBzaGFwZS53YXZlTGVuZ3RoIC8gNCwgc3RhZ2UsXG4gICAgICAgICAgICAgICAgc2hhcGUud2F2ZUxlbmd0aCwgc2hhcGUuYW1wbGl0dWRlKTtcbiAgICAgICAgICAgIGN0eC5iZXppZXJDdXJ2ZVRvKHBvc1swXVswXSArIGxlZnQsIC1wb3NbMF1bMV0gKyBzaGFwZS53YXRlckxldmVsLFxuICAgICAgICAgICAgICAgIHBvc1sxXVswXSArIGxlZnQsIC1wb3NbMV1bMV0gKyBzaGFwZS53YXRlckxldmVsLFxuICAgICAgICAgICAgICAgIHBvc1syXVswXSArIGxlZnQsIC1wb3NbMl1bMV0gKyBzaGFwZS53YXRlckxldmVsKTtcblxuICAgICAgICAgICAgaWYgKGMgPT09IGN1cnZlcyAtIDEpIHtcbiAgICAgICAgICAgICAgICB3YXZlUmlnaHQgPSBwb3NbMl1bMF07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoc2hhcGUuaW52ZXJzZSkge1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiB0b3AtcmlnaHQgY29ybmVyXG4gICAgICAgICAgICAgKiAgICAgICAgICAgICAgICAgIDIuIGRyYXdzIHRoaXMgbGluZVxuICAgICAgICAgICAgICogICAgICAgICAgICAgICAgICAgICAgICAgIHxcbiAgICAgICAgICAgICAqICAgICAgICAgICAgICAgICAgICAgICArLS0tLS0tK1xuICAgICAgICAgICAgICogMy4gZHJhd3MgdGhpcyBsaW5lIC0+IHwgICAgICB8IDwtIDEuIGRyYXdzIHRoaXMgbGluZVxuICAgICAgICAgICAgICogICAgICAgICAgICAgICAgICAgICAgIH5+fn5+fn5+XG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGN0eC5saW5lVG8od2F2ZVJpZ2h0ICsgbGVmdCwgc2hhcGUuY3kgLSBzaGFwZS5yYWRpdXNZKTtcbiAgICAgICAgICAgIGN0eC5saW5lVG8obGVmdCwgc2hhcGUuY3kgLSBzaGFwZS5yYWRpdXNZKTtcbiAgICAgICAgICAgIGN0eC5saW5lVG8obGVmdCwgc2hhcGUud2F0ZXJMZXZlbCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIHRvcC1yaWdodCBjb3JuZXJcbiAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgfn5+fn5+fn5cbiAgICAgICAgICAgICAqIDMuIGRyYXdzIHRoaXMgbGluZSAtPiB8ICAgICAgfCA8LSAxLiBkcmF3cyB0aGlzIGxpbmVcbiAgICAgICAgICAgICAqICAgICAgICAgICAgICAgICAgICAgICArLS0tLS0tK1xuICAgICAgICAgICAgICogICAgICAgICAgICAgICAgICAgICAgICAgIF5cbiAgICAgICAgICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICB8XG4gICAgICAgICAgICAgKiAgICAgICAgICAgICAgICAgIDIuIGRyYXdzIHRoaXMgbGluZVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBjdHgubGluZVRvKHdhdmVSaWdodCArIGxlZnQsIHNoYXBlLmN5ICsgc2hhcGUucmFkaXVzWSk7XG4gICAgICAgICAgICBjdHgubGluZVRvKGxlZnQsIHNoYXBlLmN5ICsgc2hhcGUucmFkaXVzWSk7XG4gICAgICAgICAgICBjdHgubGluZVRvKGxlZnQsIHNoYXBlLndhdGVyTGV2ZWwpO1xuICAgICAgICB9XG5cbiAgICAgICAgY3R4LmNsb3NlUGF0aCgpO1xuICAgIH1cbn0pO1xuXG5cblxuLyoqXG4gKiBVc2luZyBCZXppZXIgY3VydmVzIHRvIGZpdCBzaW5lIHdhdmUuXG4gKiBUaGVyZSBpcyA0IGNvbnRyb2wgcG9pbnRzIGZvciBlYWNoIGN1cnZlIG9mIHdhdmUsXG4gKiB3aGljaCBpcyBhdCAxLzQgd2F2ZSBsZW5ndGggb2YgdGhlIHNpbmUgd2F2ZS5cbiAqXG4gKiBUaGUgY29udHJvbCBwb2ludHMgZm9yIGEgd2F2ZSBmcm9tIChhKSB0byAoZCkgYXJlIGEtYi1jLWQ6XG4gKiAgICAgICAgICBjICotLS0tKiBkXG4gKiAgICAgYiAqXG4gKiAgICAgICB8XG4gKiAuLi4gYSAqIC4uLi4uLi4uLi4uLi4uLi4uLlxuICpcbiAqIHdob3NlIHBvc2l0aW9ucyBhcmUgYTogKDAsIDApLCBiOiAoMC41LCAwLjUpLCBjOiAoMSwgMSksIGQ6IChQSSAvIDIsIDEpXG4gKlxuICogQHBhcmFtIHtudW1iZXJ9IHggICAgICAgICAgeCBwb3NpdGlvbiBvZiB0aGUgbGVmdC1tb3N0IHBvaW50IChhKVxuICogQHBhcmFtIHtudW1iZXJ9IHN0YWdlICAgICAgMC0zLCBzdGF0aW5nIHdoaWNoIHBhcnQgb2YgdGhlIHdhdmUgaXQgaXNcbiAqIEBwYXJhbSB7bnVtYmVyfSB3YXZlTGVuZ3RoIHdhdmUgbGVuZ3RoIG9mIHRoZSBzaW5lIHdhdmVcbiAqIEBwYXJhbSB7bnVtYmVyfSBhbXBsaXR1ZGUgIHdhdmUgYW1wbGl0dWRlXG4gKi9cbmZ1bmN0aW9uIGdldFdhdGVyUG9zaXRpb25zKHgsIHN0YWdlLCB3YXZlTGVuZ3RoLCBhbXBsaXR1ZGUpIHtcbiAgICBpZiAoc3RhZ2UgPT09IDApIHtcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIFt4ICsgMSAvIDIgKiB3YXZlTGVuZ3RoIC8gTWF0aC5QSSAvIDIsIGFtcGxpdHVkZSAvIDJdLFxuICAgICAgICAgICAgW3ggKyAxIC8gMiAqIHdhdmVMZW5ndGggLyBNYXRoLlBJLCAgICAgYW1wbGl0dWRlXSxcbiAgICAgICAgICAgIFt4ICsgd2F2ZUxlbmd0aCAvIDQsICAgICAgICAgICAgICAgICAgIGFtcGxpdHVkZV1cbiAgICAgICAgXTtcbiAgICB9XG4gICAgZWxzZSBpZiAoc3RhZ2UgPT09IDEpIHtcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIFt4ICsgMSAvIDIgKiB3YXZlTGVuZ3RoIC8gTWF0aC5QSSAvIDIgKiAoTWF0aC5QSSAtIDIpLFxuICAgICAgICAgICAgYW1wbGl0dWRlXSxcbiAgICAgICAgICAgIFt4ICsgMSAvIDIgKiB3YXZlTGVuZ3RoIC8gTWF0aC5QSSAvIDIgKiAoTWF0aC5QSSAtIDEpLFxuICAgICAgICAgICAgYW1wbGl0dWRlIC8gMl0sXG4gICAgICAgICAgICBbeCArIHdhdmVMZW5ndGggLyA0LCAgICAgICAgICAgICAgICAgICAwXVxuICAgICAgICBdXG4gICAgfVxuICAgIGVsc2UgaWYgKHN0YWdlID09PSAyKSB7XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICBbeCArIDEgLyAyICogd2F2ZUxlbmd0aCAvIE1hdGguUEkgLyAyLCAtYW1wbGl0dWRlIC8gMl0sXG4gICAgICAgICAgICBbeCArIDEgLyAyICogd2F2ZUxlbmd0aCAvIE1hdGguUEksICAgICAtYW1wbGl0dWRlXSxcbiAgICAgICAgICAgIFt4ICsgd2F2ZUxlbmd0aCAvIDQsICAgICAgICAgICAgICAgICAgIC1hbXBsaXR1ZGVdXG4gICAgICAgIF1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICBbeCArIDEgLyAyICogd2F2ZUxlbmd0aCAvIE1hdGguUEkgLyAyICogKE1hdGguUEkgLSAyKSxcbiAgICAgICAgICAgIC1hbXBsaXR1ZGVdLFxuICAgICAgICAgICAgW3ggKyAxIC8gMiAqIHdhdmVMZW5ndGggLyBNYXRoLlBJIC8gMiAqIChNYXRoLlBJIC0gMSksXG4gICAgICAgICAgICAtYW1wbGl0dWRlIC8gMl0sXG4gICAgICAgICAgICBbeCArIHdhdmVMZW5ndGggLyA0LCAgICAgICAgICAgICAgICAgICAwXVxuICAgICAgICBdXG4gICAgfVxufVxuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/echarts-liquidfill/src/liquidFillShape.js\n");

/***/ }),

/***/ "./node_modules/echarts-liquidfill/src/liquidFillView.js":
/*!***************************************************************!*\
  !*** ./node_modules/echarts-liquidfill/src/liquidFillView.js ***!
  \***************************************************************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var echarts_lib_echarts__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! echarts/lib/echarts */ \"./node_modules/echarts/lib/echarts.js\");\n/* harmony import */ var echarts_lib_util_number__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! echarts/lib/util/number */ \"./node_modules/echarts/lib/util/number.js\");\n/* harmony import */ var _liquidFillShape__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./liquidFillShape */ \"./node_modules/echarts-liquidfill/src/liquidFillShape.js\");\n\n\n\n\nvar parsePercent = echarts_lib_util_number__WEBPACK_IMPORTED_MODULE_1__[\"parsePercent\"];\n\nfunction isPathSymbol(symbol) {\n    return symbol && symbol.indexOf('path://') === 0\n}\n\necharts_lib_echarts__WEBPACK_IMPORTED_MODULE_0__[\"extendChartView\"]({\n\n    type: 'liquidFill',\n\n    render: function (seriesModel, ecModel, api) {\n        var self = this;\n        var group = this.group;\n        group.removeAll();\n\n        var data = seriesModel.getData();\n\n        var itemModel = data.getItemModel(0);\n\n        var center = itemModel.get('center');\n        var radius = itemModel.get('radius');\n\n        var width = api.getWidth();\n        var height = api.getHeight();\n        var size = Math.min(width, height);\n        // itemStyle\n        var outlineDistance = 0;\n        var outlineBorderWidth = 0;\n        var showOutline = seriesModel.get('outline.show');\n\n        if (showOutline) {\n            outlineDistance = seriesModel.get('outline.borderDistance');\n            outlineBorderWidth = parsePercent(\n                seriesModel.get('outline.itemStyle.borderWidth'), size\n            );\n        }\n\n        var cx = parsePercent(center[0], width);\n        var cy = parsePercent(center[1], height);\n\n        var outterRadius;\n        var innerRadius;\n        var paddingRadius;\n\n        var isFillContainer = false;\n\n        var symbol = seriesModel.get('shape');\n        if (symbol === 'container') {\n            // a shape that fully fills the container\n            isFillContainer = true;\n\n            outterRadius = [\n                width / 2,\n                height / 2\n            ];\n            innerRadius = [\n                outterRadius[0] - outlineBorderWidth / 2,\n                outterRadius[1] - outlineBorderWidth / 2\n            ];\n            paddingRadius = [\n                parsePercent(outlineDistance, width),\n                parsePercent(outlineDistance, height)\n            ];\n\n            radius = [\n                Math.max(innerRadius[0] - paddingRadius[0], 0),\n                Math.max(innerRadius[1] - paddingRadius[1], 0)\n            ];\n        }\n        else {\n            outterRadius = parsePercent(radius, size) / 2;\n            innerRadius = outterRadius - outlineBorderWidth / 2;\n            paddingRadius = parsePercent(outlineDistance, size);\n\n            radius = Math.max(innerRadius - paddingRadius, 0);\n        }\n\n        if (showOutline) {\n            var outline = getOutline();\n            outline.style.lineWidth = outlineBorderWidth;\n            group.add(getOutline());\n        }\n\n        var left = isFillContainer ? 0 : cx - radius;\n        var top = isFillContainer ? 0 : cy - radius;\n\n        var wavePath = null;\n\n        group.add(getBackground());\n\n        // each data item for a wave\n        var oldData = this._data;\n        var waves = [];\n        data.diff(oldData)\n            .add(function (idx) {\n                var wave = getWave(idx, false);\n\n                var waterLevel = wave.shape.waterLevel;\n                wave.shape.waterLevel = isFillContainer ? height / 2 : radius;\n                echarts_lib_echarts__WEBPACK_IMPORTED_MODULE_0__[\"graphic\"].initProps(wave, {\n                    shape: {\n                        waterLevel: waterLevel\n                    }\n                }, seriesModel);\n\n                wave.z2 = 2;\n                setWaveAnimation(idx, wave, null);\n\n                group.add(wave);\n                data.setItemGraphicEl(idx, wave);\n                waves.push(wave);\n            })\n            .update(function (newIdx, oldIdx) {\n                var waveElement = oldData.getItemGraphicEl(oldIdx);\n\n                // new wave is used to calculate position, but not added\n                var newWave = getWave(newIdx, false, waveElement);\n\n                // changes with animation\n                var shape = {};\n                var shapeAttrs = ['amplitude', 'cx', 'cy', 'phase', 'radius', 'radiusY', 'waterLevel', 'waveLength'];\n                for (var i = 0; i < shapeAttrs.length; ++i) {\n                    var attr = shapeAttrs[i];\n                    if (newWave.shape.hasOwnProperty(attr)) {\n                        shape[attr] = newWave.shape[attr];\n                    }\n                }\n\n                var style = {};\n                var styleAttrs = ['fill', 'opacity', 'shadowBlur', 'shadowColor'];\n                for (var i = 0; i < styleAttrs.length; ++i) {\n                    var attr = styleAttrs[i];\n                    if (newWave.style.hasOwnProperty(attr)) {\n                        style[attr] = newWave.style[attr];\n                    }\n                }\n\n                if (isFillContainer) {\n                    shape.radiusY = height / 2;\n                }\n\n                // changes with animation\n                echarts_lib_echarts__WEBPACK_IMPORTED_MODULE_0__[\"graphic\"].updateProps(waveElement, {\n                    shape: shape,\n                    x: newWave.x,\n                    y: newWave.y\n                }, seriesModel);\n\n                if (seriesModel.isUniversalTransitionEnabled && seriesModel.isUniversalTransitionEnabled()) {\n                    echarts_lib_echarts__WEBPACK_IMPORTED_MODULE_0__[\"graphic\"].updateProps(waveElement, {\n                        style: style\n                    }, seriesModel);\n                }\n                else {\n                    waveElement.useStyle(style);\n                }\n\n                // instant changes\n                var oldWaveClipPath = waveElement.getClipPath();\n                var newWaveClipPath = newWave.getClipPath();\n\n                waveElement.setClipPath(newWave.getClipPath());\n                waveElement.shape.inverse = newWave.inverse;\n\n                if (oldWaveClipPath && newWaveClipPath\n                    && self._shape === symbol\n                    // TODO use zrender morphing to apply complex symbol animation.\n                    && !isPathSymbol(symbol)\n                ) {\n                    // Can be animated.\n                    echarts_lib_echarts__WEBPACK_IMPORTED_MODULE_0__[\"graphic\"].updateProps(newWaveClipPath, {\n                        shape: oldWaveClipPath.shape\n                    }, seriesModel, { isFrom: true });\n                }\n\n                setWaveAnimation(newIdx, waveElement, waveElement);\n                group.add(waveElement);\n                data.setItemGraphicEl(newIdx, waveElement);\n                waves.push(waveElement);\n            })\n            .remove(function (idx) {\n                var wave = oldData.getItemGraphicEl(idx);\n                group.remove(wave);\n            })\n            .execute();\n\n        if (itemModel.get('label.show')) {\n            group.add(getText(waves));\n        }\n\n        this._shape = symbol;\n        this._data = data;\n\n        /**\n         * Get path for outline, background and clipping\n         *\n         * @param {number} r outter radius of shape\n         * @param {boolean|undefined} isForClipping if the shape is used\n         *                                          for clipping\n         */\n        function getPath(r, isForClipping) {\n            if (symbol) {\n                // customed symbol path\n                if (isPathSymbol(symbol)) {\n                    var path = echarts_lib_echarts__WEBPACK_IMPORTED_MODULE_0__[\"graphic\"].makePath(symbol.slice(7), {});\n                    var bouding = path.getBoundingRect();\n                    var w = bouding.width;\n                    var h = bouding.height;\n                    if (w > h) {\n                        h = r * 2 / w * h;\n                        w = r * 2;\n                    }\n                    else {\n                        w = r * 2 / h * w;\n                        h = r * 2;\n                    }\n\n                    var left = isForClipping ? 0 : cx - w / 2;\n                    var top = isForClipping ? 0 : cy - h / 2;\n                    path = echarts_lib_echarts__WEBPACK_IMPORTED_MODULE_0__[\"graphic\"].makePath(\n                        symbol.slice(7),\n                        {},\n                        new echarts_lib_echarts__WEBPACK_IMPORTED_MODULE_0__[\"graphic\"].BoundingRect(left, top, w, h)\n                    );\n                    if (isForClipping) {\n                        path.x = -w / 2;\n                        path.y = -h / 2;\n                    }\n                    return path;\n                }\n                else if (isFillContainer) {\n                    // fully fill the container\n                    var x = isForClipping ? -r[0] : cx - r[0];\n                    var y = isForClipping ? -r[1] : cy - r[1];\n                    return echarts_lib_echarts__WEBPACK_IMPORTED_MODULE_0__[\"helper\"].createSymbol(\n                        'rect', x, y, r[0] * 2, r[1] * 2\n                    );\n                }\n                else {\n                    var x = isForClipping ? -r : cx - r;\n                    var y = isForClipping ? -r : cy - r;\n                    if (symbol === 'pin') {\n                        y += r;\n                    }\n                    else if (symbol === 'arrow') {\n                        y -= r;\n                    }\n                    return echarts_lib_echarts__WEBPACK_IMPORTED_MODULE_0__[\"helper\"].createSymbol(symbol, x, y, r * 2, r * 2);\n                }\n            }\n\n            return new echarts_lib_echarts__WEBPACK_IMPORTED_MODULE_0__[\"graphic\"].Circle({\n                shape: {\n                    cx: isForClipping ? 0 : cx,\n                    cy: isForClipping ? 0 : cy,\n                    r: r\n                }\n            });\n        }\n        /**\n         * Create outline\n         */\n        function getOutline() {\n            var outlinePath = getPath(outterRadius);\n            outlinePath.style.fill = null;\n\n            outlinePath.setStyle(seriesModel.getModel('outline.itemStyle')\n                .getItemStyle());\n\n            return outlinePath;\n        }\n\n        /**\n         * Create background\n         */\n        function getBackground() {\n            // Seperate stroke and fill, so we can use stroke to cover the alias of clipping.\n            var strokePath = getPath(radius);\n            strokePath.setStyle(seriesModel.getModel('backgroundStyle')\n                .getItemStyle());\n            strokePath.style.fill = null;\n\n            // Stroke is front of wave\n            strokePath.z2 = 5;\n\n            var fillPath = getPath(radius);\n            fillPath.setStyle(seriesModel.getModel('backgroundStyle')\n                .getItemStyle());\n            fillPath.style.stroke = null;\n\n            var group = new echarts_lib_echarts__WEBPACK_IMPORTED_MODULE_0__[\"graphic\"].Group();\n            group.add(strokePath);\n            group.add(fillPath);\n\n            return group;\n        }\n\n        /**\n         * wave shape\n         */\n        function getWave(idx, isInverse, oldWave) {\n            var radiusX = isFillContainer ? radius[0] : radius;\n            var radiusY = isFillContainer ? height / 2 : radius;\n\n            var itemModel = data.getItemModel(idx);\n            var itemStyleModel = itemModel.getModel('itemStyle');\n            var phase = itemModel.get('phase');\n            var amplitude = parsePercent(itemModel.get('amplitude'),\n                radiusY * 2);\n            var waveLength = parsePercent(itemModel.get('waveLength'),\n                radiusX * 2);\n\n            var value = data.get('value', idx);\n            var waterLevel = radiusY - value * radiusY * 2;\n            phase = oldWave ? oldWave.shape.phase\n                : (phase === 'auto' ? idx * Math.PI / 4 : phase);\n            var normalStyle = itemStyleModel.getItemStyle();\n            if (!normalStyle.fill) {\n                var seriesColor = seriesModel.get('color');\n                var id = idx % seriesColor.length;\n                normalStyle.fill = seriesColor[id];\n            }\n\n            var x = radiusX * 2;\n            var wave = new _liquidFillShape__WEBPACK_IMPORTED_MODULE_2__[\"default\"]({\n                shape: {\n                    waveLength: waveLength,\n                    radius: radiusX,\n                    radiusY: radiusY,\n                    cx: x,\n                    cy: 0,\n                    waterLevel: waterLevel,\n                    amplitude: amplitude,\n                    phase: phase,\n                    inverse: isInverse\n                },\n                style: normalStyle,\n                x: cx,\n                y: cy,\n            });\n            wave.shape._waterLevel = waterLevel;\n\n            var hoverStyle = itemModel.getModel('emphasis.itemStyle')\n                .getItemStyle();\n            hoverStyle.lineWidth = 0;\n\n            wave.ensureState('emphasis').style = hoverStyle;\n            echarts_lib_echarts__WEBPACK_IMPORTED_MODULE_0__[\"helper\"].enableHoverEmphasis(wave);\n\n            // clip out the part outside the circle\n            var clip = getPath(radius, true);\n            // set fill for clipPath, otherwise it will not trigger hover event\n            clip.setStyle({\n                fill: 'white'\n            });\n            wave.setClipPath(clip);\n\n            return wave;\n        }\n\n        function setWaveAnimation(idx, wave, oldWave) {\n            var itemModel = data.getItemModel(idx);\n\n            var maxSpeed = itemModel.get('period');\n            var direction = itemModel.get('direction');\n\n            var value = data.get('value', idx);\n\n            var phase = itemModel.get('phase');\n            phase = oldWave ? oldWave.shape.phase\n                : (phase === 'auto' ? idx * Math.PI / 4 : phase);\n\n            var defaultSpeed = function (maxSpeed) {\n                var cnt = data.count();\n                return cnt === 0 ? maxSpeed : maxSpeed *\n                    (0.2 + (cnt - idx) / cnt * 0.8);\n            };\n            var speed = 0;\n            if (maxSpeed === 'auto') {\n                speed = defaultSpeed(5000);\n            }\n            else {\n                speed = typeof maxSpeed === 'function'\n                    ? maxSpeed(value, idx) : maxSpeed;\n            }\n\n            // phase for moving left/right\n            var phaseOffset = 0;\n            if (direction === 'right' || direction == null) {\n                phaseOffset = Math.PI;\n            }\n            else if (direction === 'left') {\n                phaseOffset = -Math.PI;\n            }\n            else if (direction === 'none') {\n                phaseOffset = 0;\n            }\n            else {\n                console.error('Illegal direction value for liquid fill.');\n            }\n\n            // wave animation of moving left/right\n            if (direction !== 'none' && itemModel.get('waveAnimation')) {\n                wave\n                    .animate('shape', true)\n                    .when(0, {\n                        phase: phase\n                    })\n                    .when(speed / 2, {\n                        phase: phaseOffset + phase\n                    })\n                    .when(speed, {\n                        phase: phaseOffset * 2 + phase\n                    })\n                    .during(function () {\n                        if (wavePath) {\n                            wavePath.dirty(true);\n                        }\n                    })\n                    .start();\n            }\n        }\n\n        /**\n         * text on wave\n         */\n        function getText(waves) {\n            var labelModel = itemModel.getModel('label');\n\n            function formatLabel() {\n                var formatted = seriesModel.getFormattedLabel(0, 'normal');\n                var defaultVal = (data.get('value', 0) * 100);\n                var defaultLabel = data.getName(0) || seriesModel.name;\n                if (!isNaN(defaultVal)) {\n                    defaultLabel = defaultVal.toFixed(0) + '%';\n                }\n                return formatted == null ? defaultLabel : formatted;\n            }\n\n            var textRectOption = {\n                z2: 10,\n                shape: {\n                    x: left,\n                    y: top,\n                    width: (isFillContainer ? radius[0] : radius) * 2,\n                    height: (isFillContainer ? radius[1] : radius) * 2\n                },\n                style: {\n                    fill: 'transparent'\n                },\n                textConfig: {\n                    position: labelModel.get('position') || 'inside'\n                },\n                silent: true\n            };\n            var textOption = {\n                style: {\n                    text: formatLabel(),\n                    textAlign: labelModel.get('align'),\n                    textVerticalAlign: labelModel.get('baseline')\n                }\n            };\n            Object.assign(textOption.style, echarts_lib_echarts__WEBPACK_IMPORTED_MODULE_0__[\"helper\"].createTextStyle(labelModel));\n\n            var outsideTextRect = new echarts_lib_echarts__WEBPACK_IMPORTED_MODULE_0__[\"graphic\"].Rect(textRectOption);\n            var insideTextRect = new echarts_lib_echarts__WEBPACK_IMPORTED_MODULE_0__[\"graphic\"].Rect(textRectOption);\n            insideTextRect.disableLabelAnimation = true;\n            outsideTextRect.disableLabelAnimation = true;\n\n            var outsideText = new echarts_lib_echarts__WEBPACK_IMPORTED_MODULE_0__[\"graphic\"].Text(textOption);\n            var insideText = new echarts_lib_echarts__WEBPACK_IMPORTED_MODULE_0__[\"graphic\"].Text(textOption);\n            outsideTextRect.setTextContent(outsideText);\n\n            insideTextRect.setTextContent(insideText);\n            var insColor = labelModel.get('insideColor');\n            insideText.style.fill = insColor;\n\n            var group = new echarts_lib_echarts__WEBPACK_IMPORTED_MODULE_0__[\"graphic\"].Group();\n            group.add(outsideTextRect);\n            group.add(insideTextRect);\n\n            // clip out waves for insideText\n            var boundingCircle = getPath(radius, true);\n\n            wavePath = new echarts_lib_echarts__WEBPACK_IMPORTED_MODULE_0__[\"graphic\"].CompoundPath({\n                shape: {\n                    paths: waves\n                },\n                x: cx,\n                y: cy\n            });\n\n            wavePath.setClipPath(boundingCircle);\n            insideTextRect.setClipPath(wavePath);\n\n            return group;\n        }\n    },\n\n    dispose: function () {\n        // dispose nothing here\n    }\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy1saXF1aWRmaWxsL3NyYy9saXF1aWRGaWxsVmlldy5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9lY2hhcnRzLWxpcXVpZGZpbGwvc3JjL2xpcXVpZEZpbGxWaWV3LmpzP2NiN2QiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0ICogYXMgZWNoYXJ0cyBmcm9tICdlY2hhcnRzL2xpYi9lY2hhcnRzJztcbmltcG9ydCAqIGFzIG51bWJlclV0aWwgZnJvbSAnZWNoYXJ0cy9saWIvdXRpbC9udW1iZXInO1xuaW1wb3J0IExpcXVpZFNoYXBlIGZyb20gJy4vbGlxdWlkRmlsbFNoYXBlJztcblxudmFyIHBhcnNlUGVyY2VudCA9IG51bWJlclV0aWwucGFyc2VQZXJjZW50O1xuXG5mdW5jdGlvbiBpc1BhdGhTeW1ib2woc3ltYm9sKSB7XG4gICAgcmV0dXJuIHN5bWJvbCAmJiBzeW1ib2wuaW5kZXhPZigncGF0aDovLycpID09PSAwXG59XG5cbmVjaGFydHMuZXh0ZW5kQ2hhcnRWaWV3KHtcblxuICAgIHR5cGU6ICdsaXF1aWRGaWxsJyxcblxuICAgIHJlbmRlcjogZnVuY3Rpb24gKHNlcmllc01vZGVsLCBlY01vZGVsLCBhcGkpIHtcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICB2YXIgZ3JvdXAgPSB0aGlzLmdyb3VwO1xuICAgICAgICBncm91cC5yZW1vdmVBbGwoKTtcblxuICAgICAgICB2YXIgZGF0YSA9IHNlcmllc01vZGVsLmdldERhdGEoKTtcblxuICAgICAgICB2YXIgaXRlbU1vZGVsID0gZGF0YS5nZXRJdGVtTW9kZWwoMCk7XG5cbiAgICAgICAgdmFyIGNlbnRlciA9IGl0ZW1Nb2RlbC5nZXQoJ2NlbnRlcicpO1xuICAgICAgICB2YXIgcmFkaXVzID0gaXRlbU1vZGVsLmdldCgncmFkaXVzJyk7XG5cbiAgICAgICAgdmFyIHdpZHRoID0gYXBpLmdldFdpZHRoKCk7XG4gICAgICAgIHZhciBoZWlnaHQgPSBhcGkuZ2V0SGVpZ2h0KCk7XG4gICAgICAgIHZhciBzaXplID0gTWF0aC5taW4od2lkdGgsIGhlaWdodCk7XG4gICAgICAgIC8vIGl0ZW1TdHlsZVxuICAgICAgICB2YXIgb3V0bGluZURpc3RhbmNlID0gMDtcbiAgICAgICAgdmFyIG91dGxpbmVCb3JkZXJXaWR0aCA9IDA7XG4gICAgICAgIHZhciBzaG93T3V0bGluZSA9IHNlcmllc01vZGVsLmdldCgnb3V0bGluZS5zaG93Jyk7XG5cbiAgICAgICAgaWYgKHNob3dPdXRsaW5lKSB7XG4gICAgICAgICAgICBvdXRsaW5lRGlzdGFuY2UgPSBzZXJpZXNNb2RlbC5nZXQoJ291dGxpbmUuYm9yZGVyRGlzdGFuY2UnKTtcbiAgICAgICAgICAgIG91dGxpbmVCb3JkZXJXaWR0aCA9IHBhcnNlUGVyY2VudChcbiAgICAgICAgICAgICAgICBzZXJpZXNNb2RlbC5nZXQoJ291dGxpbmUuaXRlbVN0eWxlLmJvcmRlcldpZHRoJyksIHNpemVcbiAgICAgICAgICAgICk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgY3ggPSBwYXJzZVBlcmNlbnQoY2VudGVyWzBdLCB3aWR0aCk7XG4gICAgICAgIHZhciBjeSA9IHBhcnNlUGVyY2VudChjZW50ZXJbMV0sIGhlaWdodCk7XG5cbiAgICAgICAgdmFyIG91dHRlclJhZGl1cztcbiAgICAgICAgdmFyIGlubmVyUmFkaXVzO1xuICAgICAgICB2YXIgcGFkZGluZ1JhZGl1cztcblxuICAgICAgICB2YXIgaXNGaWxsQ29udGFpbmVyID0gZmFsc2U7XG5cbiAgICAgICAgdmFyIHN5bWJvbCA9IHNlcmllc01vZGVsLmdldCgnc2hhcGUnKTtcbiAgICAgICAgaWYgKHN5bWJvbCA9PT0gJ2NvbnRhaW5lcicpIHtcbiAgICAgICAgICAgIC8vIGEgc2hhcGUgdGhhdCBmdWxseSBmaWxscyB0aGUgY29udGFpbmVyXG4gICAgICAgICAgICBpc0ZpbGxDb250YWluZXIgPSB0cnVlO1xuXG4gICAgICAgICAgICBvdXR0ZXJSYWRpdXMgPSBbXG4gICAgICAgICAgICAgICAgd2lkdGggLyAyLFxuICAgICAgICAgICAgICAgIGhlaWdodCAvIDJcbiAgICAgICAgICAgIF07XG4gICAgICAgICAgICBpbm5lclJhZGl1cyA9IFtcbiAgICAgICAgICAgICAgICBvdXR0ZXJSYWRpdXNbMF0gLSBvdXRsaW5lQm9yZGVyV2lkdGggLyAyLFxuICAgICAgICAgICAgICAgIG91dHRlclJhZGl1c1sxXSAtIG91dGxpbmVCb3JkZXJXaWR0aCAvIDJcbiAgICAgICAgICAgIF07XG4gICAgICAgICAgICBwYWRkaW5nUmFkaXVzID0gW1xuICAgICAgICAgICAgICAgIHBhcnNlUGVyY2VudChvdXRsaW5lRGlzdGFuY2UsIHdpZHRoKSxcbiAgICAgICAgICAgICAgICBwYXJzZVBlcmNlbnQob3V0bGluZURpc3RhbmNlLCBoZWlnaHQpXG4gICAgICAgICAgICBdO1xuXG4gICAgICAgICAgICByYWRpdXMgPSBbXG4gICAgICAgICAgICAgICAgTWF0aC5tYXgoaW5uZXJSYWRpdXNbMF0gLSBwYWRkaW5nUmFkaXVzWzBdLCAwKSxcbiAgICAgICAgICAgICAgICBNYXRoLm1heChpbm5lclJhZGl1c1sxXSAtIHBhZGRpbmdSYWRpdXNbMV0sIDApXG4gICAgICAgICAgICBdO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgb3V0dGVyUmFkaXVzID0gcGFyc2VQZXJjZW50KHJhZGl1cywgc2l6ZSkgLyAyO1xuICAgICAgICAgICAgaW5uZXJSYWRpdXMgPSBvdXR0ZXJSYWRpdXMgLSBvdXRsaW5lQm9yZGVyV2lkdGggLyAyO1xuICAgICAgICAgICAgcGFkZGluZ1JhZGl1cyA9IHBhcnNlUGVyY2VudChvdXRsaW5lRGlzdGFuY2UsIHNpemUpO1xuXG4gICAgICAgICAgICByYWRpdXMgPSBNYXRoLm1heChpbm5lclJhZGl1cyAtIHBhZGRpbmdSYWRpdXMsIDApO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHNob3dPdXRsaW5lKSB7XG4gICAgICAgICAgICB2YXIgb3V0bGluZSA9IGdldE91dGxpbmUoKTtcbiAgICAgICAgICAgIG91dGxpbmUuc3R5bGUubGluZVdpZHRoID0gb3V0bGluZUJvcmRlcldpZHRoO1xuICAgICAgICAgICAgZ3JvdXAuYWRkKGdldE91dGxpbmUoKSk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgbGVmdCA9IGlzRmlsbENvbnRhaW5lciA/IDAgOiBjeCAtIHJhZGl1cztcbiAgICAgICAgdmFyIHRvcCA9IGlzRmlsbENvbnRhaW5lciA/IDAgOiBjeSAtIHJhZGl1cztcblxuICAgICAgICB2YXIgd2F2ZVBhdGggPSBudWxsO1xuXG4gICAgICAgIGdyb3VwLmFkZChnZXRCYWNrZ3JvdW5kKCkpO1xuXG4gICAgICAgIC8vIGVhY2ggZGF0YSBpdGVtIGZvciBhIHdhdmVcbiAgICAgICAgdmFyIG9sZERhdGEgPSB0aGlzLl9kYXRhO1xuICAgICAgICB2YXIgd2F2ZXMgPSBbXTtcbiAgICAgICAgZGF0YS5kaWZmKG9sZERhdGEpXG4gICAgICAgICAgICAuYWRkKGZ1bmN0aW9uIChpZHgpIHtcbiAgICAgICAgICAgICAgICB2YXIgd2F2ZSA9IGdldFdhdmUoaWR4LCBmYWxzZSk7XG5cbiAgICAgICAgICAgICAgICB2YXIgd2F0ZXJMZXZlbCA9IHdhdmUuc2hhcGUud2F0ZXJMZXZlbDtcbiAgICAgICAgICAgICAgICB3YXZlLnNoYXBlLndhdGVyTGV2ZWwgPSBpc0ZpbGxDb250YWluZXIgPyBoZWlnaHQgLyAyIDogcmFkaXVzO1xuICAgICAgICAgICAgICAgIGVjaGFydHMuZ3JhcGhpYy5pbml0UHJvcHMod2F2ZSwge1xuICAgICAgICAgICAgICAgICAgICBzaGFwZToge1xuICAgICAgICAgICAgICAgICAgICAgICAgd2F0ZXJMZXZlbDogd2F0ZXJMZXZlbFxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSwgc2VyaWVzTW9kZWwpO1xuXG4gICAgICAgICAgICAgICAgd2F2ZS56MiA9IDI7XG4gICAgICAgICAgICAgICAgc2V0V2F2ZUFuaW1hdGlvbihpZHgsIHdhdmUsIG51bGwpO1xuXG4gICAgICAgICAgICAgICAgZ3JvdXAuYWRkKHdhdmUpO1xuICAgICAgICAgICAgICAgIGRhdGEuc2V0SXRlbUdyYXBoaWNFbChpZHgsIHdhdmUpO1xuICAgICAgICAgICAgICAgIHdhdmVzLnB1c2god2F2ZSk7XG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgLnVwZGF0ZShmdW5jdGlvbiAobmV3SWR4LCBvbGRJZHgpIHtcbiAgICAgICAgICAgICAgICB2YXIgd2F2ZUVsZW1lbnQgPSBvbGREYXRhLmdldEl0ZW1HcmFwaGljRWwob2xkSWR4KTtcblxuICAgICAgICAgICAgICAgIC8vIG5ldyB3YXZlIGlzIHVzZWQgdG8gY2FsY3VsYXRlIHBvc2l0aW9uLCBidXQgbm90IGFkZGVkXG4gICAgICAgICAgICAgICAgdmFyIG5ld1dhdmUgPSBnZXRXYXZlKG5ld0lkeCwgZmFsc2UsIHdhdmVFbGVtZW50KTtcblxuICAgICAgICAgICAgICAgIC8vIGNoYW5nZXMgd2l0aCBhbmltYXRpb25cbiAgICAgICAgICAgICAgICB2YXIgc2hhcGUgPSB7fTtcbiAgICAgICAgICAgICAgICB2YXIgc2hhcGVBdHRycyA9IFsnYW1wbGl0dWRlJywgJ2N4JywgJ2N5JywgJ3BoYXNlJywgJ3JhZGl1cycsICdyYWRpdXNZJywgJ3dhdGVyTGV2ZWwnLCAnd2F2ZUxlbmd0aCddO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2hhcGVBdHRycy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgYXR0ciA9IHNoYXBlQXR0cnNbaV07XG4gICAgICAgICAgICAgICAgICAgIGlmIChuZXdXYXZlLnNoYXBlLmhhc093blByb3BlcnR5KGF0dHIpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzaGFwZVthdHRyXSA9IG5ld1dhdmUuc2hhcGVbYXR0cl07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB2YXIgc3R5bGUgPSB7fTtcbiAgICAgICAgICAgICAgICB2YXIgc3R5bGVBdHRycyA9IFsnZmlsbCcsICdvcGFjaXR5JywgJ3NoYWRvd0JsdXInLCAnc2hhZG93Q29sb3InXTtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHN0eWxlQXR0cnMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGF0dHIgPSBzdHlsZUF0dHJzW2ldO1xuICAgICAgICAgICAgICAgICAgICBpZiAobmV3V2F2ZS5zdHlsZS5oYXNPd25Qcm9wZXJ0eShhdHRyKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3R5bGVbYXR0cl0gPSBuZXdXYXZlLnN0eWxlW2F0dHJdO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKGlzRmlsbENvbnRhaW5lcikge1xuICAgICAgICAgICAgICAgICAgICBzaGFwZS5yYWRpdXNZID0gaGVpZ2h0IC8gMjtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBjaGFuZ2VzIHdpdGggYW5pbWF0aW9uXG4gICAgICAgICAgICAgICAgZWNoYXJ0cy5ncmFwaGljLnVwZGF0ZVByb3BzKHdhdmVFbGVtZW50LCB7XG4gICAgICAgICAgICAgICAgICAgIHNoYXBlOiBzaGFwZSxcbiAgICAgICAgICAgICAgICAgICAgeDogbmV3V2F2ZS54LFxuICAgICAgICAgICAgICAgICAgICB5OiBuZXdXYXZlLnlcbiAgICAgICAgICAgICAgICB9LCBzZXJpZXNNb2RlbCk7XG5cbiAgICAgICAgICAgICAgICBpZiAoc2VyaWVzTW9kZWwuaXNVbml2ZXJzYWxUcmFuc2l0aW9uRW5hYmxlZCAmJiBzZXJpZXNNb2RlbC5pc1VuaXZlcnNhbFRyYW5zaXRpb25FbmFibGVkKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgZWNoYXJ0cy5ncmFwaGljLnVwZGF0ZVByb3BzKHdhdmVFbGVtZW50LCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdHlsZTogc3R5bGVcbiAgICAgICAgICAgICAgICAgICAgfSwgc2VyaWVzTW9kZWwpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgd2F2ZUVsZW1lbnQudXNlU3R5bGUoc3R5bGUpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIGluc3RhbnQgY2hhbmdlc1xuICAgICAgICAgICAgICAgIHZhciBvbGRXYXZlQ2xpcFBhdGggPSB3YXZlRWxlbWVudC5nZXRDbGlwUGF0aCgpO1xuICAgICAgICAgICAgICAgIHZhciBuZXdXYXZlQ2xpcFBhdGggPSBuZXdXYXZlLmdldENsaXBQYXRoKCk7XG5cbiAgICAgICAgICAgICAgICB3YXZlRWxlbWVudC5zZXRDbGlwUGF0aChuZXdXYXZlLmdldENsaXBQYXRoKCkpO1xuICAgICAgICAgICAgICAgIHdhdmVFbGVtZW50LnNoYXBlLmludmVyc2UgPSBuZXdXYXZlLmludmVyc2U7XG5cbiAgICAgICAgICAgICAgICBpZiAob2xkV2F2ZUNsaXBQYXRoICYmIG5ld1dhdmVDbGlwUGF0aFxuICAgICAgICAgICAgICAgICAgICAmJiBzZWxmLl9zaGFwZSA9PT0gc3ltYm9sXG4gICAgICAgICAgICAgICAgICAgIC8vIFRPRE8gdXNlIHpyZW5kZXIgbW9ycGhpbmcgdG8gYXBwbHkgY29tcGxleCBzeW1ib2wgYW5pbWF0aW9uLlxuICAgICAgICAgICAgICAgICAgICAmJiAhaXNQYXRoU3ltYm9sKHN5bWJvbClcbiAgICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gQ2FuIGJlIGFuaW1hdGVkLlxuICAgICAgICAgICAgICAgICAgICBlY2hhcnRzLmdyYXBoaWMudXBkYXRlUHJvcHMobmV3V2F2ZUNsaXBQYXRoLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzaGFwZTogb2xkV2F2ZUNsaXBQYXRoLnNoYXBlXG4gICAgICAgICAgICAgICAgICAgIH0sIHNlcmllc01vZGVsLCB7IGlzRnJvbTogdHJ1ZSB9KTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBzZXRXYXZlQW5pbWF0aW9uKG5ld0lkeCwgd2F2ZUVsZW1lbnQsIHdhdmVFbGVtZW50KTtcbiAgICAgICAgICAgICAgICBncm91cC5hZGQod2F2ZUVsZW1lbnQpO1xuICAgICAgICAgICAgICAgIGRhdGEuc2V0SXRlbUdyYXBoaWNFbChuZXdJZHgsIHdhdmVFbGVtZW50KTtcbiAgICAgICAgICAgICAgICB3YXZlcy5wdXNoKHdhdmVFbGVtZW50KTtcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAucmVtb3ZlKGZ1bmN0aW9uIChpZHgpIHtcbiAgICAgICAgICAgICAgICB2YXIgd2F2ZSA9IG9sZERhdGEuZ2V0SXRlbUdyYXBoaWNFbChpZHgpO1xuICAgICAgICAgICAgICAgIGdyb3VwLnJlbW92ZSh3YXZlKTtcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAuZXhlY3V0ZSgpO1xuXG4gICAgICAgIGlmIChpdGVtTW9kZWwuZ2V0KCdsYWJlbC5zaG93JykpIHtcbiAgICAgICAgICAgIGdyb3VwLmFkZChnZXRUZXh0KHdhdmVzKSk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl9zaGFwZSA9IHN5bWJvbDtcbiAgICAgICAgdGhpcy5fZGF0YSA9IGRhdGE7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEdldCBwYXRoIGZvciBvdXRsaW5lLCBiYWNrZ3JvdW5kIGFuZCBjbGlwcGluZ1xuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gciBvdXR0ZXIgcmFkaXVzIG9mIHNoYXBlXG4gICAgICAgICAqIEBwYXJhbSB7Ym9vbGVhbnx1bmRlZmluZWR9IGlzRm9yQ2xpcHBpbmcgaWYgdGhlIHNoYXBlIGlzIHVzZWRcbiAgICAgICAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgY2xpcHBpbmdcbiAgICAgICAgICovXG4gICAgICAgIGZ1bmN0aW9uIGdldFBhdGgociwgaXNGb3JDbGlwcGluZykge1xuICAgICAgICAgICAgaWYgKHN5bWJvbCkge1xuICAgICAgICAgICAgICAgIC8vIGN1c3RvbWVkIHN5bWJvbCBwYXRoXG4gICAgICAgICAgICAgICAgaWYgKGlzUGF0aFN5bWJvbChzeW1ib2wpKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBwYXRoID0gZWNoYXJ0cy5ncmFwaGljLm1ha2VQYXRoKHN5bWJvbC5zbGljZSg3KSwge30pO1xuICAgICAgICAgICAgICAgICAgICB2YXIgYm91ZGluZyA9IHBhdGguZ2V0Qm91bmRpbmdSZWN0KCk7XG4gICAgICAgICAgICAgICAgICAgIHZhciB3ID0gYm91ZGluZy53aWR0aDtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGggPSBib3VkaW5nLmhlaWdodDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHcgPiBoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBoID0gciAqIDIgLyB3ICogaDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHcgPSByICogMjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHcgPSByICogMiAvIGggKiB3O1xuICAgICAgICAgICAgICAgICAgICAgICAgaCA9IHIgKiAyO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgdmFyIGxlZnQgPSBpc0ZvckNsaXBwaW5nID8gMCA6IGN4IC0gdyAvIDI7XG4gICAgICAgICAgICAgICAgICAgIHZhciB0b3AgPSBpc0ZvckNsaXBwaW5nID8gMCA6IGN5IC0gaCAvIDI7XG4gICAgICAgICAgICAgICAgICAgIHBhdGggPSBlY2hhcnRzLmdyYXBoaWMubWFrZVBhdGgoXG4gICAgICAgICAgICAgICAgICAgICAgICBzeW1ib2wuc2xpY2UoNyksXG4gICAgICAgICAgICAgICAgICAgICAgICB7fSxcbiAgICAgICAgICAgICAgICAgICAgICAgIG5ldyBlY2hhcnRzLmdyYXBoaWMuQm91bmRpbmdSZWN0KGxlZnQsIHRvcCwgdywgaClcbiAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzRm9yQ2xpcHBpbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhdGgueCA9IC13IC8gMjtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhdGgueSA9IC1oIC8gMjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcGF0aDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoaXNGaWxsQ29udGFpbmVyKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGZ1bGx5IGZpbGwgdGhlIGNvbnRhaW5lclxuICAgICAgICAgICAgICAgICAgICB2YXIgeCA9IGlzRm9yQ2xpcHBpbmcgPyAtclswXSA6IGN4IC0gclswXTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHkgPSBpc0ZvckNsaXBwaW5nID8gLXJbMV0gOiBjeSAtIHJbMV07XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBlY2hhcnRzLmhlbHBlci5jcmVhdGVTeW1ib2woXG4gICAgICAgICAgICAgICAgICAgICAgICAncmVjdCcsIHgsIHksIHJbMF0gKiAyLCByWzFdICogMlxuICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHggPSBpc0ZvckNsaXBwaW5nID8gLXIgOiBjeCAtIHI7XG4gICAgICAgICAgICAgICAgICAgIHZhciB5ID0gaXNGb3JDbGlwcGluZyA/IC1yIDogY3kgLSByO1xuICAgICAgICAgICAgICAgICAgICBpZiAoc3ltYm9sID09PSAncGluJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgeSArPSByO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHN5bWJvbCA9PT0gJ2Fycm93Jykge1xuICAgICAgICAgICAgICAgICAgICAgICAgeSAtPSByO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBlY2hhcnRzLmhlbHBlci5jcmVhdGVTeW1ib2woc3ltYm9sLCB4LCB5LCByICogMiwgciAqIDIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIG5ldyBlY2hhcnRzLmdyYXBoaWMuQ2lyY2xlKHtcbiAgICAgICAgICAgICAgICBzaGFwZToge1xuICAgICAgICAgICAgICAgICAgICBjeDogaXNGb3JDbGlwcGluZyA/IDAgOiBjeCxcbiAgICAgICAgICAgICAgICAgICAgY3k6IGlzRm9yQ2xpcHBpbmcgPyAwIDogY3ksXG4gICAgICAgICAgICAgICAgICAgIHI6IHJcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogQ3JlYXRlIG91dGxpbmVcbiAgICAgICAgICovXG4gICAgICAgIGZ1bmN0aW9uIGdldE91dGxpbmUoKSB7XG4gICAgICAgICAgICB2YXIgb3V0bGluZVBhdGggPSBnZXRQYXRoKG91dHRlclJhZGl1cyk7XG4gICAgICAgICAgICBvdXRsaW5lUGF0aC5zdHlsZS5maWxsID0gbnVsbDtcblxuICAgICAgICAgICAgb3V0bGluZVBhdGguc2V0U3R5bGUoc2VyaWVzTW9kZWwuZ2V0TW9kZWwoJ291dGxpbmUuaXRlbVN0eWxlJylcbiAgICAgICAgICAgICAgICAuZ2V0SXRlbVN0eWxlKCkpO1xuXG4gICAgICAgICAgICByZXR1cm4gb3V0bGluZVBhdGg7XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogQ3JlYXRlIGJhY2tncm91bmRcbiAgICAgICAgICovXG4gICAgICAgIGZ1bmN0aW9uIGdldEJhY2tncm91bmQoKSB7XG4gICAgICAgICAgICAvLyBTZXBlcmF0ZSBzdHJva2UgYW5kIGZpbGwsIHNvIHdlIGNhbiB1c2Ugc3Ryb2tlIHRvIGNvdmVyIHRoZSBhbGlhcyBvZiBjbGlwcGluZy5cbiAgICAgICAgICAgIHZhciBzdHJva2VQYXRoID0gZ2V0UGF0aChyYWRpdXMpO1xuICAgICAgICAgICAgc3Ryb2tlUGF0aC5zZXRTdHlsZShzZXJpZXNNb2RlbC5nZXRNb2RlbCgnYmFja2dyb3VuZFN0eWxlJylcbiAgICAgICAgICAgICAgICAuZ2V0SXRlbVN0eWxlKCkpO1xuICAgICAgICAgICAgc3Ryb2tlUGF0aC5zdHlsZS5maWxsID0gbnVsbDtcblxuICAgICAgICAgICAgLy8gU3Ryb2tlIGlzIGZyb250IG9mIHdhdmVcbiAgICAgICAgICAgIHN0cm9rZVBhdGguejIgPSA1O1xuXG4gICAgICAgICAgICB2YXIgZmlsbFBhdGggPSBnZXRQYXRoKHJhZGl1cyk7XG4gICAgICAgICAgICBmaWxsUGF0aC5zZXRTdHlsZShzZXJpZXNNb2RlbC5nZXRNb2RlbCgnYmFja2dyb3VuZFN0eWxlJylcbiAgICAgICAgICAgICAgICAuZ2V0SXRlbVN0eWxlKCkpO1xuICAgICAgICAgICAgZmlsbFBhdGguc3R5bGUuc3Ryb2tlID0gbnVsbDtcblxuICAgICAgICAgICAgdmFyIGdyb3VwID0gbmV3IGVjaGFydHMuZ3JhcGhpYy5Hcm91cCgpO1xuICAgICAgICAgICAgZ3JvdXAuYWRkKHN0cm9rZVBhdGgpO1xuICAgICAgICAgICAgZ3JvdXAuYWRkKGZpbGxQYXRoKTtcblxuICAgICAgICAgICAgcmV0dXJuIGdyb3VwO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIHdhdmUgc2hhcGVcbiAgICAgICAgICovXG4gICAgICAgIGZ1bmN0aW9uIGdldFdhdmUoaWR4LCBpc0ludmVyc2UsIG9sZFdhdmUpIHtcbiAgICAgICAgICAgIHZhciByYWRpdXNYID0gaXNGaWxsQ29udGFpbmVyID8gcmFkaXVzWzBdIDogcmFkaXVzO1xuICAgICAgICAgICAgdmFyIHJhZGl1c1kgPSBpc0ZpbGxDb250YWluZXIgPyBoZWlnaHQgLyAyIDogcmFkaXVzO1xuXG4gICAgICAgICAgICB2YXIgaXRlbU1vZGVsID0gZGF0YS5nZXRJdGVtTW9kZWwoaWR4KTtcbiAgICAgICAgICAgIHZhciBpdGVtU3R5bGVNb2RlbCA9IGl0ZW1Nb2RlbC5nZXRNb2RlbCgnaXRlbVN0eWxlJyk7XG4gICAgICAgICAgICB2YXIgcGhhc2UgPSBpdGVtTW9kZWwuZ2V0KCdwaGFzZScpO1xuICAgICAgICAgICAgdmFyIGFtcGxpdHVkZSA9IHBhcnNlUGVyY2VudChpdGVtTW9kZWwuZ2V0KCdhbXBsaXR1ZGUnKSxcbiAgICAgICAgICAgICAgICByYWRpdXNZICogMik7XG4gICAgICAgICAgICB2YXIgd2F2ZUxlbmd0aCA9IHBhcnNlUGVyY2VudChpdGVtTW9kZWwuZ2V0KCd3YXZlTGVuZ3RoJyksXG4gICAgICAgICAgICAgICAgcmFkaXVzWCAqIDIpO1xuXG4gICAgICAgICAgICB2YXIgdmFsdWUgPSBkYXRhLmdldCgndmFsdWUnLCBpZHgpO1xuICAgICAgICAgICAgdmFyIHdhdGVyTGV2ZWwgPSByYWRpdXNZIC0gdmFsdWUgKiByYWRpdXNZICogMjtcbiAgICAgICAgICAgIHBoYXNlID0gb2xkV2F2ZSA/IG9sZFdhdmUuc2hhcGUucGhhc2VcbiAgICAgICAgICAgICAgICA6IChwaGFzZSA9PT0gJ2F1dG8nID8gaWR4ICogTWF0aC5QSSAvIDQgOiBwaGFzZSk7XG4gICAgICAgICAgICB2YXIgbm9ybWFsU3R5bGUgPSBpdGVtU3R5bGVNb2RlbC5nZXRJdGVtU3R5bGUoKTtcbiAgICAgICAgICAgIGlmICghbm9ybWFsU3R5bGUuZmlsbCkge1xuICAgICAgICAgICAgICAgIHZhciBzZXJpZXNDb2xvciA9IHNlcmllc01vZGVsLmdldCgnY29sb3InKTtcbiAgICAgICAgICAgICAgICB2YXIgaWQgPSBpZHggJSBzZXJpZXNDb2xvci5sZW5ndGg7XG4gICAgICAgICAgICAgICAgbm9ybWFsU3R5bGUuZmlsbCA9IHNlcmllc0NvbG9yW2lkXTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIHggPSByYWRpdXNYICogMjtcbiAgICAgICAgICAgIHZhciB3YXZlID0gbmV3IExpcXVpZFNoYXBlKHtcbiAgICAgICAgICAgICAgICBzaGFwZToge1xuICAgICAgICAgICAgICAgICAgICB3YXZlTGVuZ3RoOiB3YXZlTGVuZ3RoLFxuICAgICAgICAgICAgICAgICAgICByYWRpdXM6IHJhZGl1c1gsXG4gICAgICAgICAgICAgICAgICAgIHJhZGl1c1k6IHJhZGl1c1ksXG4gICAgICAgICAgICAgICAgICAgIGN4OiB4LFxuICAgICAgICAgICAgICAgICAgICBjeTogMCxcbiAgICAgICAgICAgICAgICAgICAgd2F0ZXJMZXZlbDogd2F0ZXJMZXZlbCxcbiAgICAgICAgICAgICAgICAgICAgYW1wbGl0dWRlOiBhbXBsaXR1ZGUsXG4gICAgICAgICAgICAgICAgICAgIHBoYXNlOiBwaGFzZSxcbiAgICAgICAgICAgICAgICAgICAgaW52ZXJzZTogaXNJbnZlcnNlXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBzdHlsZTogbm9ybWFsU3R5bGUsXG4gICAgICAgICAgICAgICAgeDogY3gsXG4gICAgICAgICAgICAgICAgeTogY3ksXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHdhdmUuc2hhcGUuX3dhdGVyTGV2ZWwgPSB3YXRlckxldmVsO1xuXG4gICAgICAgICAgICB2YXIgaG92ZXJTdHlsZSA9IGl0ZW1Nb2RlbC5nZXRNb2RlbCgnZW1waGFzaXMuaXRlbVN0eWxlJylcbiAgICAgICAgICAgICAgICAuZ2V0SXRlbVN0eWxlKCk7XG4gICAgICAgICAgICBob3ZlclN0eWxlLmxpbmVXaWR0aCA9IDA7XG5cbiAgICAgICAgICAgIHdhdmUuZW5zdXJlU3RhdGUoJ2VtcGhhc2lzJykuc3R5bGUgPSBob3ZlclN0eWxlO1xuICAgICAgICAgICAgZWNoYXJ0cy5oZWxwZXIuZW5hYmxlSG92ZXJFbXBoYXNpcyh3YXZlKTtcblxuICAgICAgICAgICAgLy8gY2xpcCBvdXQgdGhlIHBhcnQgb3V0c2lkZSB0aGUgY2lyY2xlXG4gICAgICAgICAgICB2YXIgY2xpcCA9IGdldFBhdGgocmFkaXVzLCB0cnVlKTtcbiAgICAgICAgICAgIC8vIHNldCBmaWxsIGZvciBjbGlwUGF0aCwgb3RoZXJ3aXNlIGl0IHdpbGwgbm90IHRyaWdnZXIgaG92ZXIgZXZlbnRcbiAgICAgICAgICAgIGNsaXAuc2V0U3R5bGUoe1xuICAgICAgICAgICAgICAgIGZpbGw6ICd3aGl0ZSdcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgd2F2ZS5zZXRDbGlwUGF0aChjbGlwKTtcblxuICAgICAgICAgICAgcmV0dXJuIHdhdmU7XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBzZXRXYXZlQW5pbWF0aW9uKGlkeCwgd2F2ZSwgb2xkV2F2ZSkge1xuICAgICAgICAgICAgdmFyIGl0ZW1Nb2RlbCA9IGRhdGEuZ2V0SXRlbU1vZGVsKGlkeCk7XG5cbiAgICAgICAgICAgIHZhciBtYXhTcGVlZCA9IGl0ZW1Nb2RlbC5nZXQoJ3BlcmlvZCcpO1xuICAgICAgICAgICAgdmFyIGRpcmVjdGlvbiA9IGl0ZW1Nb2RlbC5nZXQoJ2RpcmVjdGlvbicpO1xuXG4gICAgICAgICAgICB2YXIgdmFsdWUgPSBkYXRhLmdldCgndmFsdWUnLCBpZHgpO1xuXG4gICAgICAgICAgICB2YXIgcGhhc2UgPSBpdGVtTW9kZWwuZ2V0KCdwaGFzZScpO1xuICAgICAgICAgICAgcGhhc2UgPSBvbGRXYXZlID8gb2xkV2F2ZS5zaGFwZS5waGFzZVxuICAgICAgICAgICAgICAgIDogKHBoYXNlID09PSAnYXV0bycgPyBpZHggKiBNYXRoLlBJIC8gNCA6IHBoYXNlKTtcblxuICAgICAgICAgICAgdmFyIGRlZmF1bHRTcGVlZCA9IGZ1bmN0aW9uIChtYXhTcGVlZCkge1xuICAgICAgICAgICAgICAgIHZhciBjbnQgPSBkYXRhLmNvdW50KCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNudCA9PT0gMCA/IG1heFNwZWVkIDogbWF4U3BlZWQgKlxuICAgICAgICAgICAgICAgICAgICAoMC4yICsgKGNudCAtIGlkeCkgLyBjbnQgKiAwLjgpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHZhciBzcGVlZCA9IDA7XG4gICAgICAgICAgICBpZiAobWF4U3BlZWQgPT09ICdhdXRvJykge1xuICAgICAgICAgICAgICAgIHNwZWVkID0gZGVmYXVsdFNwZWVkKDUwMDApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgc3BlZWQgPSB0eXBlb2YgbWF4U3BlZWQgPT09ICdmdW5jdGlvbidcbiAgICAgICAgICAgICAgICAgICAgPyBtYXhTcGVlZCh2YWx1ZSwgaWR4KSA6IG1heFNwZWVkO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBwaGFzZSBmb3IgbW92aW5nIGxlZnQvcmlnaHRcbiAgICAgICAgICAgIHZhciBwaGFzZU9mZnNldCA9IDA7XG4gICAgICAgICAgICBpZiAoZGlyZWN0aW9uID09PSAncmlnaHQnIHx8IGRpcmVjdGlvbiA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcGhhc2VPZmZzZXQgPSBNYXRoLlBJO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoZGlyZWN0aW9uID09PSAnbGVmdCcpIHtcbiAgICAgICAgICAgICAgICBwaGFzZU9mZnNldCA9IC1NYXRoLlBJO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoZGlyZWN0aW9uID09PSAnbm9uZScpIHtcbiAgICAgICAgICAgICAgICBwaGFzZU9mZnNldCA9IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKCdJbGxlZ2FsIGRpcmVjdGlvbiB2YWx1ZSBmb3IgbGlxdWlkIGZpbGwuJyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIHdhdmUgYW5pbWF0aW9uIG9mIG1vdmluZyBsZWZ0L3JpZ2h0XG4gICAgICAgICAgICBpZiAoZGlyZWN0aW9uICE9PSAnbm9uZScgJiYgaXRlbU1vZGVsLmdldCgnd2F2ZUFuaW1hdGlvbicpKSB7XG4gICAgICAgICAgICAgICAgd2F2ZVxuICAgICAgICAgICAgICAgICAgICAuYW5pbWF0ZSgnc2hhcGUnLCB0cnVlKVxuICAgICAgICAgICAgICAgICAgICAud2hlbigwLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwaGFzZTogcGhhc2VcbiAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgLndoZW4oc3BlZWQgLyAyLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwaGFzZTogcGhhc2VPZmZzZXQgKyBwaGFzZVxuICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgICAud2hlbihzcGVlZCwge1xuICAgICAgICAgICAgICAgICAgICAgICAgcGhhc2U6IHBoYXNlT2Zmc2V0ICogMiArIHBoYXNlXG4gICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICAgIC5kdXJpbmcoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHdhdmVQYXRoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgd2F2ZVBhdGguZGlydHkodHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICAgIC5zdGFydCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIHRleHQgb24gd2F2ZVxuICAgICAgICAgKi9cbiAgICAgICAgZnVuY3Rpb24gZ2V0VGV4dCh3YXZlcykge1xuICAgICAgICAgICAgdmFyIGxhYmVsTW9kZWwgPSBpdGVtTW9kZWwuZ2V0TW9kZWwoJ2xhYmVsJyk7XG5cbiAgICAgICAgICAgIGZ1bmN0aW9uIGZvcm1hdExhYmVsKCkge1xuICAgICAgICAgICAgICAgIHZhciBmb3JtYXR0ZWQgPSBzZXJpZXNNb2RlbC5nZXRGb3JtYXR0ZWRMYWJlbCgwLCAnbm9ybWFsJyk7XG4gICAgICAgICAgICAgICAgdmFyIGRlZmF1bHRWYWwgPSAoZGF0YS5nZXQoJ3ZhbHVlJywgMCkgKiAxMDApO1xuICAgICAgICAgICAgICAgIHZhciBkZWZhdWx0TGFiZWwgPSBkYXRhLmdldE5hbWUoMCkgfHwgc2VyaWVzTW9kZWwubmFtZTtcbiAgICAgICAgICAgICAgICBpZiAoIWlzTmFOKGRlZmF1bHRWYWwpKSB7XG4gICAgICAgICAgICAgICAgICAgIGRlZmF1bHRMYWJlbCA9IGRlZmF1bHRWYWwudG9GaXhlZCgwKSArICclJztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZvcm1hdHRlZCA9PSBudWxsID8gZGVmYXVsdExhYmVsIDogZm9ybWF0dGVkO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgdGV4dFJlY3RPcHRpb24gPSB7XG4gICAgICAgICAgICAgICAgejI6IDEwLFxuICAgICAgICAgICAgICAgIHNoYXBlOiB7XG4gICAgICAgICAgICAgICAgICAgIHg6IGxlZnQsXG4gICAgICAgICAgICAgICAgICAgIHk6IHRvcCxcbiAgICAgICAgICAgICAgICAgICAgd2lkdGg6IChpc0ZpbGxDb250YWluZXIgPyByYWRpdXNbMF0gOiByYWRpdXMpICogMixcbiAgICAgICAgICAgICAgICAgICAgaGVpZ2h0OiAoaXNGaWxsQ29udGFpbmVyID8gcmFkaXVzWzFdIDogcmFkaXVzKSAqIDJcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHN0eWxlOiB7XG4gICAgICAgICAgICAgICAgICAgIGZpbGw6ICd0cmFuc3BhcmVudCdcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHRleHRDb25maWc6IHtcbiAgICAgICAgICAgICAgICAgICAgcG9zaXRpb246IGxhYmVsTW9kZWwuZ2V0KCdwb3NpdGlvbicpIHx8ICdpbnNpZGUnXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBzaWxlbnQ6IHRydWVcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB2YXIgdGV4dE9wdGlvbiA9IHtcbiAgICAgICAgICAgICAgICBzdHlsZToge1xuICAgICAgICAgICAgICAgICAgICB0ZXh0OiBmb3JtYXRMYWJlbCgpLFxuICAgICAgICAgICAgICAgICAgICB0ZXh0QWxpZ246IGxhYmVsTW9kZWwuZ2V0KCdhbGlnbicpLFxuICAgICAgICAgICAgICAgICAgICB0ZXh0VmVydGljYWxBbGlnbjogbGFiZWxNb2RlbC5nZXQoJ2Jhc2VsaW5lJylcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgT2JqZWN0LmFzc2lnbih0ZXh0T3B0aW9uLnN0eWxlLCBlY2hhcnRzLmhlbHBlci5jcmVhdGVUZXh0U3R5bGUobGFiZWxNb2RlbCkpO1xuXG4gICAgICAgICAgICB2YXIgb3V0c2lkZVRleHRSZWN0ID0gbmV3IGVjaGFydHMuZ3JhcGhpYy5SZWN0KHRleHRSZWN0T3B0aW9uKTtcbiAgICAgICAgICAgIHZhciBpbnNpZGVUZXh0UmVjdCA9IG5ldyBlY2hhcnRzLmdyYXBoaWMuUmVjdCh0ZXh0UmVjdE9wdGlvbik7XG4gICAgICAgICAgICBpbnNpZGVUZXh0UmVjdC5kaXNhYmxlTGFiZWxBbmltYXRpb24gPSB0cnVlO1xuICAgICAgICAgICAgb3V0c2lkZVRleHRSZWN0LmRpc2FibGVMYWJlbEFuaW1hdGlvbiA9IHRydWU7XG5cbiAgICAgICAgICAgIHZhciBvdXRzaWRlVGV4dCA9IG5ldyBlY2hhcnRzLmdyYXBoaWMuVGV4dCh0ZXh0T3B0aW9uKTtcbiAgICAgICAgICAgIHZhciBpbnNpZGVUZXh0ID0gbmV3IGVjaGFydHMuZ3JhcGhpYy5UZXh0KHRleHRPcHRpb24pO1xuICAgICAgICAgICAgb3V0c2lkZVRleHRSZWN0LnNldFRleHRDb250ZW50KG91dHNpZGVUZXh0KTtcblxuICAgICAgICAgICAgaW5zaWRlVGV4dFJlY3Quc2V0VGV4dENvbnRlbnQoaW5zaWRlVGV4dCk7XG4gICAgICAgICAgICB2YXIgaW5zQ29sb3IgPSBsYWJlbE1vZGVsLmdldCgnaW5zaWRlQ29sb3InKTtcbiAgICAgICAgICAgIGluc2lkZVRleHQuc3R5bGUuZmlsbCA9IGluc0NvbG9yO1xuXG4gICAgICAgICAgICB2YXIgZ3JvdXAgPSBuZXcgZWNoYXJ0cy5ncmFwaGljLkdyb3VwKCk7XG4gICAgICAgICAgICBncm91cC5hZGQob3V0c2lkZVRleHRSZWN0KTtcbiAgICAgICAgICAgIGdyb3VwLmFkZChpbnNpZGVUZXh0UmVjdCk7XG5cbiAgICAgICAgICAgIC8vIGNsaXAgb3V0IHdhdmVzIGZvciBpbnNpZGVUZXh0XG4gICAgICAgICAgICB2YXIgYm91bmRpbmdDaXJjbGUgPSBnZXRQYXRoKHJhZGl1cywgdHJ1ZSk7XG5cbiAgICAgICAgICAgIHdhdmVQYXRoID0gbmV3IGVjaGFydHMuZ3JhcGhpYy5Db21wb3VuZFBhdGgoe1xuICAgICAgICAgICAgICAgIHNoYXBlOiB7XG4gICAgICAgICAgICAgICAgICAgIHBhdGhzOiB3YXZlc1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgeDogY3gsXG4gICAgICAgICAgICAgICAgeTogY3lcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICB3YXZlUGF0aC5zZXRDbGlwUGF0aChib3VuZGluZ0NpcmNsZSk7XG4gICAgICAgICAgICBpbnNpZGVUZXh0UmVjdC5zZXRDbGlwUGF0aCh3YXZlUGF0aCk7XG5cbiAgICAgICAgICAgIHJldHVybiBncm91cDtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBkaXNwb3NlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8vIGRpc3Bvc2Ugbm90aGluZyBoZXJlXG4gICAgfVxufSk7XG4iXSwibWFwcGluZ3MiOiJBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/echarts-liquidfill/src/liquidFillView.js\n");

/***/ })

}]);